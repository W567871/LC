package LC90;
import java.util.*;

// Subsets II
// https://leetcode.com/problems/subsets-ii/submissions/878701811/
// Solution inspired by https://www.youtube.com/watch?v=Vn2v6ajA7U0&list=PLot-Xpze53lf5C3HSjCnyFghlW0G1HHXo&index=22


// The idea is basically to use a binary decision tree to generate all subsets. The decision is based on a decision to use a "number" for "yes" branch, and not to use a "number" for the "no" branch(including all the same duplicate numbers in "nums" array).  
// Unfortunatedly, it seems there is no "DP" based solution which is going to work because of duplicates

class Solution {

    private int[] nums;
    List<List<Integer>> results = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        this.nums = nums;

        //Sort is needed to bypass duplicated numbers 
        Arrays.sort(this.nums);

        List<Integer> subSet = new ArrayList<>();       
        dfs(0, subSet);
        return results; 
    }

    private void dfs(int idx, List<Integer> curSet) {

        // when "idx == nums.length", which means each decision has been made on every individual candidate number in "nums" (the decision on whether to include a number or not), and the decision tree has reached the leaf level of the tree, so whatever the numbers have been left on the "curSet" should be added to the "results", which will be a new valid subset.   
        if (idx == nums.length) {
            results.add(new ArrayList<>(curSet));
            return;
        }

        // this is dfs recursion on "yes" decision branch (include current number num[i])
        curSet.add(nums[idx]);
        dfs(idx + 1, curSet);

        // this is "no" branch, first remove the number added by "yes" branch, so basically this will start dfs recurse on "no" branch
        curSet.remove(curSet.size() - 1);

        // bypass all duplicate numbers same to the "num[i]", because those subsets from these duplicate numbers have all been generated by the above "yes" branch of the "num[i]" 
        while (nums.length > (idx + 1) && nums[idx + 1] == nums[idx]) {
            ++idx;
        }

        // dfs recurse on "no" branch. Note: the empty set "[]" will be the last subset added to the "results" when every decision on each number is "no"
        dfs(idx + 1, curSet);
    }

    
}